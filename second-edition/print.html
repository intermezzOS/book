<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The intermezzOS Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="src/theme/extra.css">
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="background/index.html"><strong aria-hidden="true">1.</strong> Background</a></li><li><ol class="section"><li><a href="background/what.html"><strong aria-hidden="true">1.1.</strong> What is an OS?</a></li><li><a href="background/what-kind-is-there.html"><strong aria-hidden="true">1.2.</strong> What kinds of OS are there?</a></li><li><a href="background/what-kind-are-we-making.html"><strong aria-hidden="true">1.3.</strong> What kind are we making?</a></li><li><a href="background/tools.html"><strong aria-hidden="true">1.4.</strong> What tools will we use?</a></li></ol></li><li><a href="hello-world/index.html"><strong aria-hidden="true">2.</strong> From Zero to &quot;Hello, world!&quot;</a></li><li><ol class="section"><li><a href="hello-world/setup.html"><strong aria-hidden="true">2.1.</strong> Setting up a development environment</a></li><li><a href="hello-world/setting-up-a-project.html"><strong aria-hidden="true">2.2.</strong> Setting up a project</a></li><li><a href="hello-world/from-zero-to-start-in-detail.html"><strong aria-hidden="true">2.3.</strong> From zero to _start in detail</a></li></ol></li><li><a href="fractal-learning.html"><strong aria-hidden="true">3.</strong> Interlude: fractal learning</a></li><li><a href="vga/index.html"><strong aria-hidden="true">4.</strong> Printing to the screen: a text mode VGA driver</a></li><li><ol class="section"><li><a href="vga/hello-world.html"><strong aria-hidden="true">4.1.</strong> A VGA &quot;hello world&quot;</a></li><li><a href="vga/understanding-text-mode.html"><strong aria-hidden="true">4.2.</strong> Understanding text mode</a></li><li><a href="vga/nicer-implementation.html"><strong aria-hidden="true">4.3.</strong> A nicer implementation</a></li><li class="spacer"></li></ol></li><li><a href="appendix/target-specifications.html">Appendix A: target specifications</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The intermezzOS Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 class="center">intermezzOS</h1>
<p><img class="center" src="assets/rhizome.jpg" alt="rhizome" /></p>
<p class="center">An operating system for learning</p>
<a class="header" href="print.html#preface" id="preface"><h2>Preface</h2></a>
<p>This book describes the intermezzOS project. intermezzOS is a hobby operating
system, specifically targeted at showing beginners how to get into operating
systems development. Rather than describe some sort of final OS, it instead
proceeds in a tutorial-like fashion, allowing you to implement intermezzOS
yourself, alongside the book.</p>
<p>The book assumes that you have programmed in some language before, but not any
particular one. In fact, people who have not done low-level programming before
are a specific target of this book; I’ll be explaining a lot of things that
other resources will just assume that you know.</p>
<p>intermezzOS is implemented in <a href="https://www.rust-lang.org/">Rust</a>, and some
assembly code. We’ll try to explain Rust along the way, but may refer you to
its documentation when things get tricky. This book isn’t <em>really</em> about
learning Rust, but you might accidentally along the way.</p>
<p>You can find all of this stuff <a href="https://github.com/intermezzOS/">on GitHub</a>.
This book is in the <code>book</code> repository, the kernel is in <code>kernel</code>, and the
website is there too. Feel free to open issues if you want to discuss things
in a general sense, and send bug reports and PRs to the appropriate repos if
you’d like to help with a particular component.</p>
<a class="header" href="print.html#the-story" id="the-story"><h2>The Story</h2></a>
<p>A long time ago, in college, my friends and I were working on a hobby operating
system, <a href="http://xomb.org">XOmB</a>. It was... tough. Frankly, while I learned a
lot, I was a pretty minor contributor. I got frustrated too easily. One day, I
found Ruby, and I was pretty much done with low-level programming. I had done
it most of my life, and I was bored. Bored, and sick of dealing with core
dumps.</p>
<p>Those details aren’t that important. What is important is that over the years,
I’ve always wanted to get back into this stuff. But the problem is this: there
are a lot of people who do hobby operating system work, but... I don’t like
their attitudes.</p>
<p>You see, a lot of people see low-level programming as some kind of superior,
only-for-the-smartest kind of thing. They have a puritanical world-view: “I
suffered to learn this, so you too must suffer to build character.” I think
that’s short sighted. Low level programming <em>is</em> difficult to get into, but
that says more about the teachers’ faults than the students’.</p>
<p>Anyway, as my professional life has moved back towards the low level, I’ve been
thinking about this topic a lot again. That’s when I found an awesome link:
<a href="http://os.phil-opp.com/">Writing an OS in Rust by Philipp Oppermann</a>. I cannot speak enough
about how awesome Phil’s tutorial is; it single-handedly inspired me to get
back into operating systems.</p>
<p>The big difference with Phil’s tutorial is that it doesn’t treat you as being
stupid for not knowing ‘the basics’. It doesn’t say “spend hours debugging this
thing, because I did.” It doesn’t insult you for being new. It just explains
the basics of a kernel.</p>
<p>It’s amazing how much a little bit of a framing can completely change the way
you see something. When the examples I found were all about how you have to be
an amazing rockstar ninja and we won’t give you all the code because you suck
if you can’t figure it out, I hated this stuff. When it was kind,
understanding, and helpful, I couldn’t get enough.</p>
<p>Once I got to a certain part in Phil’s tutorial, I started implementing stuff
myself. A lot of the initial code here is going to be similar to Phil’s.
But I’m going to write about it anyway. There’s a good reason for that:</p>
<blockquote>
<p>Writing is nature’s way of showing us how sloppy our thinking is.</p>
<ul>
<li>Leslie Lamport</li>
</ul>
</blockquote>
<p>By re-explaining things in my own words, I hope to understand it even better.
This is just a perpetual theme with me: I like teaching because it helps me
learn. I like writing because it helps me understand.</p>
<p>We'll be using a tool Phil developed called <code>bootimage</code>, and we'll explain
similar concepts, but with different code and in different ways, and in a
different order.</p>
<p>Furthermore, I will not commit to any kind of schedule for this project. It’s
going to be in my spare time, and I’m learning a lot of this as I go, too.</p>
<a class="header" href="print.html#the-name" id="the-name"><h2>The Name</h2></a>
<blockquote>
<p>The nomad has a territory; he follows customary paths; he goes from one point
to another; he is not ignorant of points (water points, dwelling points,
assembly points, etc.). But the question is what in nomad life is a principle
and what is only a consequence. To begin with, although the points determine
paths, they are strictly subordinated to the paths they determine, the
reverse happens with the sedentary. The water point is reached only in order
to be left behind; every point is a relay and exists only as a relay. A path
is always between two points, but the in-between has taken on all the
consistency and enjoys both an autonomy and a direction of its own. The life
of the nomad is the intermezzo.</p>
<p>Deleuze and Guattari, “A Thousand Plateaus”, p380</p>
</blockquote>
<p>If you’re not into particular kinds of philosophy, this quote won’t mean a lot.
Let’s look at the dictionary definition:</p>
<blockquote>
<p>An intermezzo, in the most general sense, is a composition which fits between
other musical or dramatic entities, such as acts of a play or movements of a
larger musical work.</p>
<p><a href="https://en.wikipedia.org/wiki/Intermezzo">https://en.wikipedia.org/wiki/Intermezzo</a></p>
</blockquote>
<p>I want this project to be about learning. Learning is often referred to as a
journey. You start off in ignorance and end in knowledge. In other words,
‘learning’ is that part in the middle, the in-between state.</p>
<p>The tricky thing about learning is, you never stop learning. Once you learn
something, there’s something new to learn, and you’re on a journey again.</p>
<p>If you want to learn a lot, then you’ll find yourself perpetually in the
middle.</p>
<p>There is another sense by which this name makes sense: as we’ll learn in the
beginning of the book, operating systems are largely about abstractions. And
abstractions are themselves ‘in the middle’, between what they’re abstracting
and who they are abstracting it for.</p>
<a class="header" href="print.html#principles" id="principles"><h2>Principles</h2></a>
<p>Here are the guiding principles of intermezzOS:</p>
<ul>
<li>We’re all actual people. Please treat each other as such.</li>
<li>We’re all here to learn. Let’s help each other learn, rather than being some
kind of vanguard of knowledge.</li>
<li>The only thing that matters about your language background is the amount you
may have to learn.</li>
<li>Everything must be documented, or it’s not done.</li>
</ul>
<p>And of course, everything related to this project is under the <a href="http://intermezzos.github.io/code-of-conduct.html">Code of
Conduct</a>.</p>
<a class="header" href="print.html#background" id="background"><h1>Background</h1></a>
<p>Before we get going, we should probably have some idea of where we’re headed.</p>
<a class="header" href="print.html#what-is-an-os" id="what-is-an-os"><h1>What is an OS?</h1></a>
<p>It’s actually kind of difficult to define what an operating system is. There
are a lot of different kinds of operating systems, and they all do different
kinds of things.</p>
<p>Some things are commonly bundled with operating systems, but are arguably not
part of the essence of what makes an OS an OS. For example, many operating
systems are often marketed as coming equipped with a web browser or email
client. Are web browsers and email clients essential to operating systems?
Many would argue the answer is no.</p>
<p>There are some shared goals we can find among all operating systems, however.
Let’s try this out as a working definition:</p>
<blockquote>
<p>An operating system is a program that provides a platform for other
programs. It provides two things to these programs: abstractions and
isolation.</p>
</blockquote>
<p>This is good enough for now. Let’s consider this a test for inclusion,
but not exclusion. In other words, things that fit this definition
<em>are</em> operating systems, but things that don’t may or may not be,
we don’t quite know.</p>
<a class="header" href="print.html#creating-abstractions" id="creating-abstractions"><h2>Creating abstractions</h2></a>
<p>There are many reasons to create a platform for other programs, but a
common one for operating systems is to abstract over hardware.</p>
<p>Consider a program, running on some hardware:</p>
<p><img alt="program on hardware" class="center" src="assets/program_hardware.png" /></p>
<p>This program will need to know <em>exactly</em> about what kind of hardware exists.
If you want to run it on a different computer, it will have to know exactly
about that computer too. And if you want to write a second program, you’ll
have to re-write a bunch of code for interacting with the hardware.</p>
<blockquote>
<p>All problems in computer science can be solved by another level of
indirection.</p>
<ul>
<li>David Wheeler</li>
</ul>
</blockquote>
<p>To solve this problem, we can introduce an abstraction:</p>
<p><img alt="program on os on hardware" class="center" src="assets/program_os_hardware.png" /></p>
<p>Now, the operating system can handle the details of the hardware, and provide
an API for it. A program can be written for that operating system’s API, and
can then run on any hardware that the operating system supports.</p>
<p>At some point, though, we developed many operating systems. Since operating
systems are platforms, most people pick one and have only that one on their
computer. So now we have a problem that looks the same, but is a bit
different: our program is now specific to an OS, rather than specific to
a particular bit of hardware.</p>
<p>To solve this, some programming languages have a ‘virtual machine.’ This
was a big selling point of Java, for example: the Java Virtual Machine.
The idea here is that we create a <em>virtual</em> machine on top of the <em>real</em>
machine.</p>
<p><img alt="program on vm " class="center" src="assets/program_vm_os_hardware.png" /></p>
<p>Now, you write programs for the Java Virtual Machine, which is then ported
to each operating system, which is then ported to all the hardware. Whew!</p>
<p>This, of course, leads to the corollary to the previous maxim:</p>
<blockquote>
<p>...except for the problem of too many layers of indirection.</p>
<ul>
<li>Kevlin Henney</li>
</ul>
</blockquote>
<p>We now have a pattern:</p>
<ul>
<li>I have <code>A</code>.</li>
<li><code>A</code> is written explicitly for <code>X</code>...</li>
<li>... but I want to support <code>X</code> and <code>Y</code>,</li>
<li>so I put abstraction <code>B</code> in the middle.</li>
</ul>
<p>We will see this pattern over and over again. Hence ‘intermezzo’: abstractions
are always in the middle.</p>
<a class="header" href="print.html#isolation" id="isolation"><h2>Isolation</h2></a>
<p>Many of the abstractions provided are, as we discussed, abstractions over
hardware. And hardware often has a pretty serious restriction: only one
program can access the hardware at a time. So if our operating system is going
to be able to run multiple programs, which is a common feature of many
operating systems, we’ll also need to make sure that multiple programs cannot
access hardware at the same time.</p>
<p>This really applies to more than just hardware though: it also applies to
shared resources (e.g. memory). Once we have two programs, it would
be ideal to not let them mess with each other. Consider any sort of program that
deals with your password: if programs could mess with each other’s memory
and code, then a program could trivially steal your password from another program!</p>
<p>This is just one symptom of a general problem. It’s much better to isolate
programs from each other, for a number of different reasons. For now, we’ll
just consider isolation as one of our important jobs, as OS authors.</p>
<a class="header" href="print.html#wait-a-minute" id="wait-a-minute"><h3>Wait a minute...</h3></a>
<p>Here’s a question for you to ponder: if we didn’t provide isolation, isn’t that
just a poor abstraction? In other words, if we had an abstraction where we
could interact with other things being abstracted... isn’t that just a bad job
of doing the abstraction? And in that sense, is the only thing an operating
system does abstraction? Is the only thing everything does abstraction?</p>
<p>I don’t have answers for you. If you figure it out, let me know...</p>
<a class="header" href="print.html#what-kinds-of-os-are-there" id="what-kinds-of-os-are-there"><h1>What kinds of OS are there?</h1></a>
<p>Okay, so here’s the thing: operating systems are made up of a <em>lot</em> of components.
The core component is called a ‘kernel’. The non-kernel bits of an operating system
are collectively called a ‘userland’. Typically a kernel has more direct access to the
machine than a userland and thus acts somewhat like a super user (with powers that even
‘sudo’ cannot give you). A kernel forms the basis of the abstractions and isolations.
So, as OS developers, when we categorize operating systems, we tend to categorize them
by what kinds of kernel they have.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>Although you may be used to hearing the term ‘Linux’ used as a name for an
operating system, you may hear some people say, “It’s GNU/Linux, not Linux.”
That’s because virtually all Linux distributions today use a Linux kernel + a
GNU userland. So the GNU folks are a bit annoyed that the kernel gets all
the credit. By the same token, a lot of people say ‘the kernel’ when they mean
‘the Linux kernel.’ This gets an entirely different set of people mad.</p>
</blockquote>
<p>At the start, our ‘operating system’ will be just the kernel, and so we’ll tend
to focus on kernels for the first part of our journey.</p>
<p>The way that we categorize different kernels largely comes down to “what is in
the kernel and what is in userspace.” Upon reading this, you might then think
the easiest kind of kernel to write is the smallest, where everything is in
userspace. After all, smaller should be easier, right? Well... that’s not
actually true. Or at least, it’s not clear that it’s true.</p>
<a class="header" href="print.html#monolithic-kernels" id="monolithic-kernels"><h2>Monolithic kernels</h2></a>
<p>First, we have ‘monolithic kernels’. ‘Mono’ meaning ‘one’. One big ol’ kernel.
Most real-world kernels are monolithic kernels, or at least, pretend to be.
Don’t worry about it. Linux, for example, is a monolithic kernel.</p>
<p>This means that monolithic kernels are kind of ‘the default’. Other kernels
usually define themselves by solving some kind of problem that monolithic
kernels have.</p>
<p>If a monolithic kernel were a web application, it would be a big ol’ Rails
application. One repository. A million subdirectories. It may be a big ball
of mud, but it pays the bills.</p>
<a class="header" href="print.html#microkernels" id="microkernels"><h2>Microkernels</h2></a>
<p>Microkernels are, well, micro. Smaller. A lot of the functionality that’s typically in
the kernel is in userspace instead. This is a good idea in theory, but
historically, microkernels have had issues. All that communication has
overhead, which makes them slower.</p>
<p>Mach, the kernel that Mac OS X uses, is a microkernel. Well, sort of. It ended
up being one, but Mac OS X uses a version of Mach from before that work was
done... so it’s a bit blurry.</p>
<p>If a microkernel were a web application, it would be a microservice. And a
bunch of the other stuff that’s in kernel space in a monolithic kernel are
other microservices, but in userspace instead. It’s a bit cooler than a single
monolithic web app by itself, and the communication is nice for flexibility’s
sake, but has some overhead.</p>
<a class="header" href="print.html#exokernels--unikernels" id="exokernels--unikernels"><h2>Exokernels &amp; Unikernels</h2></a>
<p>These two kinds of operating systems are closely related, but it’s a bit harder
to dig into what exactly makes them different. Unikernels have one
easy-to-describe feature: they only run one single program at a time.
Exokernels are ‘more micro than micro’, but the details aren’t important right
now.</p>
<p>The important thing to know here is that there are a lot of other kinds of
designs than just monolithic vs. micro. There’s a lot of stuff to learn!</p>
<a class="header" href="print.html#what-kind-are-we-making" id="what-kind-are-we-making"><h1>What kind are we making?</h1></a>
<p>So, given all these kinds of operating systems, what kind are we making?</p>
<p>The answer is “it doesn’t even matter at first.” There’s some commonality in
almost all of these styles of operating systems, and we have to get all that
done before we even make those decisions.</p>
<p>Secondly, we could waste a <em>lot</em> of time trying to design our perfect OS. And
then never actually build it. Remember, the goal here is <em>to learn</em>, not <em>to
make the best OS that ever existed</em>. So really, what it ends up looking like
just doesn’t really matter at all. Most hobby operating system projects die
quite young.</p>
<p>Let’s focus on the <em>doing</em>, and less on the categorization, planning, and
being. A nice thing about operating systems is that there’s a lot of freedom of
direction. To tie it back into the example earlier, Phil’s tutorial starts
going into memory-management after getting printing to the screen going. We’ll
be going into keyboards first instead. There are, of course, some dependencies,
but there’s also a lot of freedom.</p>
<a class="header" href="print.html#what-tools-will-we-use" id="what-tools-will-we-use"><h1>What tools will we use?</h1></a>
<p>Before we can make a kernel, we need to figure out the tools we’re going to
use. The first question, of course, is what programming language?</p>
<p>In our case, we’re going to use two. The first one is the language that
<em>every</em> kernel must use: assembly language.</p>
<a class="header" href="print.html#assembly" id="assembly"><h2>Assembly</h2></a>
<p>Assembly language gives us direct access to a specific machine. If the basis of
computer science is abstraction, the very bottom of the software abstraction layer
is assembly. Below it lies only hardware and physics.</p>
<p>There are many kinds of assembly languages each targeted at different
‘instruction set’ architectures (also known as ISA or simply as instruction sets).
These instruction sets are the list of commands that a given CPU can understand. For
example, if your computer has an Intel Pentium processor of some kind then it
understands the x86 instruction set. So if you were to write assembly for another
instruction set (say MIPS or ARM), you would not be able to run it on your computer.</p>
<p>This is one of the reasons we'll want to get away from the assembly world as
fast as possible. If we want our kernel to work for a bunch of different
architectures, any code we end up writing in assembly will need to be duplicated.
However, if we use a more high-level language like C, C++ or the language we'll
really be using, Rust, we can write the code once and cross-compile
to different architectures.</p>
<p>Assembly language looks like this:</p>
<pre><code class="language-x86asm">; foo.asm

section .data
global _start

_start:
    mov rax, 0
loop:
    add rax, 1
    cmp rax, 10
    jne loop

    mov rbx, rax
    mov rax, 1
    int 80h
</code></pre>
<p>This is a little program in assembly language. If it looks totally alien to you,
don't worry. While we could write our entire kernel in assembly, we'll only be
learning as much assembly as we need to not have to use it any more.</p>
<p>When you write assembly language you are actually directly manipulating the
individual registers of the CPU and memory inside of RAM and other hardware
devices like CD drives or display screens.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>CPUs are composed of registers each of which can only hold small amounts of data.
The amount of data a register can hold dictates what type of CPU the register
belongs to. If you didn't know why your machine is classified as either 32 bit
or 64 bit it's because the machine's registers can either hold 32 bits of data at a
time or 64 bits at a time.</p>
</blockquote>
<p>In assembly we can only do very simple things: move data between registers or
to/from RAM; perform simple arithmetic like addition, subtraction, multiplication
and division; compare values in different registers, and based on these comparisons
jump to different points in our code (à la GOTO). Fancy high level concepts
like while loops and if statements, let alone garbage collection are nowhere to be
found. Even functions as you know them aren't really supported in assembly.
Each assembly program is just a bunch of data in registers or in memory and a
list of instructions, carried out one after the other.</p>
<p>For instance, in our code above we used the <code>mov</code> instruction several times to
move values into specific registers with weird names like <code>rax</code> and <code>rbx</code>. We
used the <code>cmp</code> instruction to compare the value inside of the <code>rax</code> register
with the number <code>10</code>. We used the <code>jne</code> instruction to jump to another part of
our code if the numbers we just compared were not equal. Finally we used the <code>int</code>
instruction to trigger a hardware <em>int</em>errupt.</p>
<p>Again, you don't need to fully understand this program at this point. Right now
you should just have an impression for how assembly is composed of simple
instructions that do very simple things.</p>
<p>When it comes time to write some actual assembly code we'll touch on all this again.</p>
<p>Let's run this little program:</p>
<pre><code class="language-bash">$ nasm -f elf64 foo.asm # assemble into foo.o
$ ld foo.o              # link into a.out
$ ./a.out               # run it
$ echo $?               # print out the exit code
10
$
</code></pre>
<p>Don't worry too much about what programs we're using to actually compile (or
‘assemble’ as it's known in the assembly world) our program. We'll be going
over each one of these commands and explaining what they are and how to use
them.</p>
<a class="header" href="print.html#rust" id="rust"><h2>Rust</h2></a>
<p>We will augment our assembly with code written in
<a href="https://www.rust-lang.org/">Rust</a>. In fact, we will be trying to get to
Rust-land as quickly as we possibly can. Rust is a really great programming
language, and it’s pretty great for writing operating systems. It has some
rough edges, but they’re not too big of a deal.</p>
<p>Rust will allow us to write:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">// foo.rs

use std::process;

fn main() {
    let mut a = 0;

    for _ in 0..10 {
        a = a + 1;
    }

    process::exit(a);
}
</code></pre></pre>
<p>This does the same thing as our assembly code:</p>
<pre><code class="language-bash">$ rustc foo.rs # compile our Rust code to foo
$ ./foo        # run it
$ echo $?      # print out the exit code
10
$
</code></pre>
<p>That Rust code probably looks more like a programming language you’ve used in
the past. It’s a lot nicer to write complex things in a higher-level
programming language like Rust. That said, virtually all languages are
higher-level than assembly, so that’s not saying all that much. Rust is still a
low-level language by many standards.</p>
<p>So why choose Rust? Well, I’m picking it for two reasons:</p>
<ol>
<li>I love it.</li>
<li>There aren’t a lot of kernels in it yet.</li>
</ol>
<p>There are a suprising number of people working on kernels in Rust. But since
it’s a newer language, there aren’t nearly as many as for older, more
established languages.</p>
<a class="header" href="print.html#do-i-need-to-be-a-wizard" id="do-i-need-to-be-a-wizard"><h2>Do I need to be a wizard?</h2></a>
<p>No, you do not. A common theme of this project is “this is all we’ll need to
know about this topic for now.” There’s no reason that you need to absolutely
master everything before going forward. For example, in order to get Rust
going, we need only about 100 lines of assembly, as mentioned above. Do you
need to be a complete expert in assembly language to understand those well
enough to keep going? Not at all. Will learning more about it help? Absolutely!</p>
<p>There’s nobody that’s monitoring your credentials to see if you’re allowed to
move on. Do it at your own pace. Skip stuff. Come back when you don’t
understand what’s going on. Try it, wait a week, and then try it again.</p>
<p>There’s no wrong way to do this stuff, including by being a beginner. Everyone
was once. Don’t let anyone discourage you.</p>
<a class="header" href="print.html#from-zero-to-hello-world" id="from-zero-to-hello-world"><h1>From Zero to &quot;Hello, world!&quot;</h1></a>
<p>A &quot;hello world&quot; program is traditional amongst programmers as your first program. This dates back
to 1972, in the &quot;Tutorial Introduction to the Language B&quot;, a language that proceeded C. A &quot;hello world&quot;
program does nothing other than print out the words &quot;hello, world&quot; to the screen. While it's fun to
participate in traditions, it also serves a practical purpose: if you can get this simple program
working, you know that you've installed everything correctly, you've got your build set up, and that
everything is working.</p>
<p>In this chapter, we'll:</p>
<ul>
<li>Set up a development environment</li>
<li>Get everything building</li>
<li>Boot up our OS and print &quot;Hello world&quot; to the screen</li>
</ul>
<p>Let's get started!</p>
<a class="header" href="print.html#setting-up-a-development-environment" id="setting-up-a-development-environment"><h1>Setting up a development environment</h1></a>
<p>Traditionally, getting a development environment set up for working on an
operating system is really hard. However, we have it pretty easy! We'll be
using the <a href="https://www.rust-lang.org/">Rust programming language</a> to develop our kernel, and thanks to
some awesome work by the language developers, as well as the homebrew Rust
operating system community, getting our environment set up is really easy.</p>
<p>To get going, you'll need a few tools:</p>
<ul>
<li>An editor or IDE to write the source code</li>
<li>A compiler and other tools to turn that source code into binary code</li>
<li>A virtual machine to try our OS out without installing it on our computer</li>
<li>A project directory to do develop in</li>
</ul>
<p>You can get all of these tools working on Windows, macOS, and Linux. Other
operating systems may work, but we've only tried this on these systems. This
section is the only one with OS-specific instructions; from here on out,
everything will be identical.</p>
<a class="header" href="print.html#an-editor-or-ide" id="an-editor-or-ide"><h2>An editor or IDE</h2></a>
<p>This is needed, but is also largely a personal choice. You can use whatever
you'd like here, and that's 100% fine.</p>
<p>If you're not sure what to use, I do have two recommendations though. If
you prefer text editiors, give <a href="https://code.visualstudio.com/">Visual Studio: Code</a> a try. It's fairly
light-weight, but also has some nice features, and a great Rust plugin
provided by the Rust team.</p>
<p>If you prefer IDEs, I'd suggest <a href="https://www.jetbrains.com/clion/">Clion</a> with the Rust plugin. JetBrains
makes a suite of IDEs for a ton of languages, and their Rust support is
solid!</p>
<p>Really, anything works though: I use both of the above, and also <code>vim</code> at
times. It's just not a huge deal.</p>
<a class="header" href="print.html#the-compiler-and-other-tools" id="the-compiler-and-other-tools"><h2>The compiler and other tools</h2></a>
<p>Next, we need to get the Rust compiler installed. To do that, head to
<a href="https://www.rust-lang.org/en-US/install.html">Rust's install page</a> and follow the instructions. You can also install
Rust another way if you'd prefer, such as from your system's package
manager, but through the website is generally easiest.</p>
<p>This will give you a tool called <code>rustup</code>, used to manage versions of
<code>rustc</code>, the Rust compiler, and Cargo, the package manager and
build tool. To check that this was installed properly, run these
three commands and check that you get some output:</p>
<pre><code class="language-bash">$ rustup --version
$ rustc --version
$ cargo --version
</code></pre>
<p>If you do, everything's good!</p>
<a class="header" href="print.html#stable-vs-nightly-rust" id="stable-vs-nightly-rust"><h3>Stable vs. Nightly Rust</h3></a>
<p>One of the reasons that it's easiest is that you can't use any version
of Rust to develop OSes; you need &quot;nightly&quot; Rust. Basically, Rust comes
in different flavors, and in order to develop operating systems, we need
to use some experimental, cutting-edge features. As such, we can't use
the stable Rust distribution, we need the nightly one.</p>
<p>To install nightly, do this:</p>
<pre><code class="language-bash">$ rustup update nightly
</code></pre>
<p>This will download and install the nightly toolchain. We'll configure the
use of this toolchain automatically in the next section.</p>
<a class="header" href="print.html#other-tools" id="other-tools"><h3>Other tools</h3></a>
<p>We need to install two more tools for building our OS. The first is
called <code>bootimage</code>, and its job is to take our kernel and produce a file
that our virtual machine (discussed in the next section) knows how to
run. To install it:</p>
<pre><code class="language-bash">$ cargo install bootimage
</code></pre>
<p>To check that it installed correctly, run this:</p>
<pre><code class="language-bash">$ bootimage --help
</code></pre>
<p>And you should see a help message printed to the screen.</p>
<p>The second tool is called <code>cargo-xbuild</code>. It extends Cargo, allowing us to
build Rust's core libraries for other OSes than the ones provided by the Rust
team. To install it:</p>
<pre><code class="language-bash">$ cargo install cargo-xbuild
</code></pre>
<p>And to check that it was installed correctly, run this:</p>
<pre><code class="language-bash">$ cargo xbuild --version
</code></pre>
<p>And make sure that you get some version output.</p>
<p>Additionally, to do its job, <code>cargo-xbuild</code> needs the source code for these
core libraries; to get those, run this:</p>
<pre><code class="language-bash">$ rustup component add rust-src --toolchain=nightly
</code></pre>
<p>With that, we're all set up!</p>
<a class="header" href="print.html#a-virtual-machine" id="a-virtual-machine"><h2>A virtual machine</h2></a>
<p>In order to see that your code runs, you <em>could</em> install it on a real computer,
but that is way too complex for regular development. Instead, we can use a virtual
machine to give our OS a try locally.</p>
<p>There's a few options, but for this, we'll use <a href="https://www.qemu.org/">Qemu</a>. Qemu works on all of our
platforms, and has enough features for us too. <a href="https://www.qemu.org/download/">Qemu's downloads page</a> should help
you get it installed.</p>
<p>To check that it's working, try this:</p>
<pre><code class="language-bash">$  qemu-system-x86_64 --version
</code></pre>
<p>And make sure it spits out a version number.</p>
<a class="header" href="print.html#a-project-directory" id="a-project-directory"><h2>A project directory</h2></a>
<p>Finally, we need to put our source code somewhere. This can be wherever you'd like,
but for this book, we'll call ours <code>~/src/</code>. You'll see examples have this path in
the output, just to have something, but you can do this anywhere you'd like. We'll
call this &quot;your project directory&quot; a few times in the book, and we mean wherever you
decided to put stuff.</p>
<a class="header" href="print.html#thats-it" id="thats-it"><h2>That's it!</h2></a>
<p>With that, we're done! Let's actually get some code going!</p>
<a class="header" href="print.html#setting-up-a-project" id="setting-up-a-project"><h1>Setting up a project</h1></a>
<p>Now that we are all set up, let's get going! First, let's go to our project
directory:</p>
<pre><code class="language-bash">$ cd ~/src
</code></pre>
<p>And then, we'll use <code>cargo new</code> to create a new binary project:</p>
<pre><code class="language-bash">$ cargo new --bin intermezzos
     Created binary (application) `intermezzos` project
</code></pre>
<blockquote>
<p>Feel free to name your kernel something else!</p>
</blockquote>
<p>This will create a new directory, <code>intermezzos</code>, inside our project
directory. Let's move into it:</p>
<pre><code class="language-bash">$ cd intermezzos
</code></pre>
<p>Cargo has created three things for us: a <code>src/main.rs</code> file, that contains
our Rust source code. A <code>Cargo.toml</code>, which contains metadata about our
project. And finally, a <code>.gitignore</code>, if you use <code>git</code>.</p>
<blockquote>
<p>Sidebar: Rust knowledge</p>
<p>We don't inherently assume that you know Rust well, but this book also
isn't a Rust tutorial. We'll try to explain the basics of the code we're
writing, but you may want to check out <a href="https://doc.rust-lang.org/book/second-edition/">The Rust Programming
Language</a> if you don't
understand our basic explanations here. If you've never used Rust before, you
might want to take a moment and skim <a href="https://doc.rust-lang.org/book/second-edition/ch03-00-common-programming-concepts.html">Chapter
3</a>,
which covers the basic syntax and talks about stuff you've seen in
programming languages you have used in the past.</p>
</blockquote>
<a class="header" href="print.html#our-first-hello-world" id="our-first-hello-world"><h2>Our first Hello, World</h2></a>
<p>If you investigate the contents of <code>src/main.rs</code>, you'll find this:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo generated a &quot;hello world&quot; program for us! Let's try it out:</p>
<pre><code class="language-bash">$ cargo run
   Compiling intermezzos v0.1.0 (file:///~/src/intermezzos)
    Finished dev [unoptimized + debuginfo] target(s) in 2.5 secs
     Running `target/debug/intermezzos.exe`
Hello, world!
</code></pre>
<p>If you see the &quot;Hello, world!&quot; printed to your screen, then your Rust toolchain is working!</p>
<a class="header" href="print.html#hosts-and-targets" id="hosts-and-targets"><h2>Hosts and Targets</h2></a>
<p>This program is compiled for our own computer hardware and operating system.
The computer we're compiling <em>from</em> is called the &quot;host system.&quot; But, our new
OS won't be using the OS of the computer we're doing development on! The
computer we want to compile <em>to</em> is called the &quot;target system.&quot;</p>
<p>When the host and target system are the same, most people just say
&quot;compiling.&quot; When they host and taget are different, people say that you're
&quot;cross-compiling.&quot;</p>
<p>To cross-compile, <code>cargo</code> takes an argument, <code>--target</code>. We can then tell it
what kind of computer we want to compile to, and it will do the right thing.
However, by default, Rust can't know every single kind of computer and OS
that we would want to compile to: after all, we're creating a new OS right
now!</p>
<p>To solve this, we need to write some JSON.</p>
<a class="header" href="print.html#creating-intermezzosjson" id="creating-intermezzosjson"><h3>Creating intermezzos.json</h3></a>
<p>Rust has a feature called &quot;target specifications&quot; that lets us, well, specify
a target. To do that, we create a JSON file, and use it to describe all the
things that the compiler needs to know in order to generate the proper code.</p>
<p>Create a new file named <code>intermezzos.json</code> and put this in it:</p>
<pre><code class="language-json">{
  &quot;llvm-target&quot;: &quot;x86_64-unknown-none&quot;,
  &quot;data-layout&quot;: &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;,
  &quot;arch&quot;: &quot;x86_64&quot;,
  &quot;target-endian&quot;: &quot;little&quot;,
  &quot;target-pointer-width&quot;: &quot;64&quot;,
  &quot;target-c-int-width&quot;: &quot;32&quot;,
  &quot;os&quot;: &quot;none&quot;,
  &quot;linker&quot;: &quot;rust-lld&quot;,
  &quot;linker-flavor&quot;: &quot;ld.lld&quot;,
  &quot;executables&quot;: true,
  &quot;features&quot;: &quot;-mmx,-sse,+soft-float&quot;,
  &quot;disable-redzone&quot;: true,
  &quot;panic-strategy&quot;: &quot;abort&quot;
}
</code></pre>
<p>To learn more about this file, check out Appendix A. For now, it's mostly a
distraction; you don't <em>need</em> to know what's going on here to continue.</p>
<a class="header" href="print.html#removing-the-standard-library" id="removing-the-standard-library"><h2>Removing the standard library</h2></a>
<p>Okay, let's write some Rust! Delete the code in <code>src/main.rs</code>, and replace it
with this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(panic_implementation)]
#![feature(core_intrinsics)]
#![no_std]
#![no_main]

#fn main() {
extern crate bootloader_precompiled;

use core::intrinsics;
use core::panic::PanicInfo;

#[panic_implementation]
#[no_mangle]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    unsafe { intrinsics::abort() }
}

#[no_mangle]
pub fn _start() -&gt; ! {
    loop {}
}
#}</code></pre></pre>
<p>Let's go over the code, bit by bit:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ...

#![no_std]
#![no_main]

// ...
#}</code></pre></pre>
<p>These two attributes tell Rust, &quot;hey, we don't want a standard library, and
we don't want a <code>main</code> function.&quot; When writing an OS, we want full control
over the details. The Rust standard library assumes that an operating system
exists, and we don't have any of that yet, so we can't use it. Rust's default
<code>main</code> includes stuff that we <em>could</em> use, but it's nicer to write our own,
so we have that full control.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(panic_implementation)]
#![feature(core_intrinsics)]

#fn main() {
// ... 

extern crate bootloader_precompiled;

use core::intrinsics;
use core::panic::PanicInfo;

#[panic_implementation]
#[no_mangle]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    unsafe { intrinsics::abort() }
}
#}</code></pre></pre>
<p>When we don't include the standard library, then we're missing one important
thing: if we <code>panic!</code>, Rust wants to call a callback before aborting. This is
that callback. All we do is abort our program.</p>
<p>The <code>extern crate</code> line will set up our bootloader, that is, the code that
loads our OS after the computer starts up. We'll talk more about this later.</p>
<p>Other than that, this is boilerplate. We'll talk about this stuff more when we
actually do something on panics; for now, don't worry about it.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ...

#[no_mangle]
pub fn _start() -&gt; ! {
    loop {}
}
#}</code></pre></pre>
<p>This is our <code>main</code> function, even though it's named <code>_start</code>. Have you ever
wondered how <code>main</code> gets called? Technically, <code>_start</code> gets called first,
then that calls your <code>main</code> function. Any setup code goes in <code>_start</code>, and
would run before it calls <code>main</code>.</p>
<p>Let's explain this function in a <em>bit</em> more detail. The <code>#[no_mangle]</code>
attribute says &quot;hey Rust, it's really important that this function is named
<em>exactly</em> this.&quot; You see, Rust is free to rename functions for you. There's
good reasons for this that we won't get into here. This attribute disables
that. If Rust renamed this function, then we wouldn't be able to boot up
properly. We'll explain more in the next section.</p>
<p>The <code>!</code> return type means we never return, and we never return because the
only thing we do is <code>loop</code> forever!</p>
<p>With this code, our little kernel will start, and then do nothing. It's a
start!</p>
<a class="header" href="print.html#aborting-on-panic" id="aborting-on-panic"><h2>Aborting on panic</h2></a>
<p>While we set up a panic handler, that's not the only thing that occurs on
a panic. After our handler is called, Rust can do one of two things: abort
the entire program, or &quot;unwind the stack.&quot; Since we're an OS, if our OS
panics, we want to abort. Unwinding can be useful for some applications, but
not an OS, as if we crash, it's all over. As such, we're going to skip over
explaining what unwinding is for now, and simply set things up to abort. Go
into <code>Cargo.toml</code> and add these lines:</p>
<pre><code class="language-toml">[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;
</code></pre>
<p>Cargo has a concept of &quot;release profiles&quot; that let us get a development
build or a release build. With this configuration, we're telling the
Rust compiler that we want to abort when a panic occurs.</p>
<a class="header" href="print.html#including-a-bootloader" id="including-a-bootloader"><h2>Including a bootloader</h2></a>
<p>Earlier we had an <code>extern crate</code> line talking about <code>bootloader_precompiled</code>.
We need to add that to our <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
bootloader_precompiled = &quot;0.2.0&quot;
</code></pre>
<a class="header" href="print.html#compiling-with-bootimage" id="compiling-with-bootimage"><h2>Compiling with <code>bootimage</code></h2></a>
<p>Now that we have our code, it's time to compile it! First, we want to make
sure that we are using the nightly version of Rust, so run this:</p>
<pre><code class="language-bash">$ rustup override set nightly
</code></pre>
<p>Now, any time we're in this project, <code>rustup</code> will ensure we're using nightly
Rust, automatically.</p>
<p>To build the project, we use the <em>bootimage</em> tool we installed earlier. Run
this:</p>
<pre><code class="language-bash">$ bootimage build --target=intermezzos.json
</code></pre>
<p>The target flag must have the same name as the <code>.json</code> file you've made, so
if you picked a different name, make sure to use it here!</p>
<p>You should see some output that looks like this:</p>
<pre><code class="language-bash">$ bootimage --target=intermezzos
   Compiling core v0.0.0 (file:///~/.rustup/toolchains/nightly-x86_64-pc-windows-msvc/lib/rustlib/src/rust/src/libcore)
    Finished release [optimized] target(s) in 65.72 secs
   Compiling intermezzos v0.1.0 (file:///~/src/intermezzos/intermezzos)
    Finished dev [unoptimized + debuginfo] target(s) in 0.82 secs
Downloading bootloader...
Creating disk image at bootimage.bin
</code></pre>
<p>If you remember from Chapter 2, we installed two tools: <code>bootimage</code> and
<code>cargo-xbuild</code>. In this case, what happens is:</p>
<ul>
<li><code>bootimage</code> calls <code>xargo</code> to compile <code>libcore</code>, Rust's smallest library.</li>
<li><code>cargo-xbuild</code> calls <code>cargo</code> to build our OS, passing flags to use that new
<code>libcore</code>.</li>
<li><code>cargo</code> calls <code>rustc</code> to actually compile our OS's code itself.</li>
<li><code>bootimage</code> then takes our code and makes a <code>.bin</code> file.</li>
</ul>
<p>Whew! That's a lot of stuff. We'll go over the details of what exactly these
steps mean in the next section. But at this point, if <code>bootimage.bin</code> exists,
you've successfully compiled your very first OS! It doesn't do much, but
everyone starts somewhere.</p>
<a class="header" href="print.html#running-with-qemu" id="running-with-qemu"><h2>Running with <code>qemu</code></h2></a>
<p>Let's try running it! To load up our OS in <code>qemu</code>, type this:</p>
<pre><code class="language-bash">$ qemu-system-x86_64 -drive format=raw,file=bootimage.bin
</code></pre>
<p>You should hopefully get something that looks like this:</p>
<p><img alt="program on hardware" class="center" src="assets/qemu.png" /></p>
<p>Hooray! Since our OS does nothing, we get a blank screen. To be clear, this
is emulating hardware, and our OS is running on it, on our own computer.
Excellent!</p>
<p>Let's step back slightly and go over what that command does:</p>
<pre><code class="language-bash">qemu-system-x86_64
</code></pre>
<p><code>qemu</code> installs virtual machines for all kinds of systems, we specifically
want an <code>x86_64</code> machine, so we need to invoke the command that will start
it.</p>
<pre><code class="language-bash">-drive
</code></pre>
<p>This parameter sets up a disk drive for our virtual machine. We need one of
those so that it knows what to actually load.</p>
<pre><code class="language-bash">format=raw,file=bootimage.bin
</code></pre>
<p>This is the value of the <code>-drive</code> parameter. It's split into two parts; the
first is that we want the format to be 'raw', that is, just use the bytes
directly, it's not formatted as a specific filesystem. The second is the file
that we want to actually load for that disk; it's our <code>bootimage.bin</code> file we
just produced with <code>bootimage</code>.</p>
<a class="header" href="print.html#some-conveniences" id="some-conveniences"><h2>Some conveniences</h2></a>
<p><code>bootimage</code> can make this even easier! Go to your <code>Cargo.toml</code>, and add
this section:</p>
<pre><code class="language-toml">[package.metadata.bootimage]
default-target = &quot;intermezzos.json&quot;
</code></pre>
<p>If you named your JSON file something different, use that name.</p>
<p>Once we've done this, we can do:</p>
<pre><code class="language-shell">$ bootimage build
$ bootimage run
</code></pre>
<p>With this, <code>bootimage build</code> will default to <code>--target=intermezzos.json</code>, and
<code>bootimage run</code> will run the same Qemu command we've been using so far. This
is much more convenient!</p>
<p>For more info, see <a href="https://github.com/rust-osdev/bootimage#configuration">bootimage's
documentation</a>.</p>
<a class="header" href="print.html#conclusion" id="conclusion"><h2>Conclusion</h2></a>
<p>Congrats! This is the first step on our journey building operating systems.
It only gets cooler from here. But before we move on, let's take a step back
and investigate in a bit more depth what we actually just did.</p>
<a class="header" href="print.html#from-zero-to-_start-in-detail" id="from-zero-to-_start-in-detail"><h1>From zero to <code>_start</code> in detail</h1></a>
<p>We now have a little kernel. But we used a lot of tools to make it happen.
What do these tools actually <em>do</em>? This section is titled &quot;in detail,&quot; but
it's really &quot;in more detail than we've seen thus far.&quot; We're going to talk
about what happens, so you can dig in deeper if you're interested, but we
can't possibly cover every single bit in depth.</p>
<p>Here's the basic set of steps:</p>
<ol>
<li>We write our kernel code.</li>
<li>We build it with <code>bootimage build</code>.
<ol>
<li>This invokes <code>cargo-xbuild</code> to cross-compile <code>libcore</code>.</li>
<li>It then invokes <code>cargo</code> to take our configuration and set up a build.</li>
<li>Cargo invokes <code>rustc</code> to actually build the code.</li>
<li>It then takes a precompiled 'bootloader' and our kernel and makes a <code>.bin</code> file.</li>
</ol>
</li>
<li>We run it with <code>bootimage run</code>.
<ol>
<li>This takes our <code>.bin</code> file, and runs Qeumu, using that <code>.bin</code> as its hard drive.</li>
</ol>
</li>
</ol>
<p>Whew! That's a lot of stuff. It's not completely different from writing any Rust
program, however: you write code, you build it, then you run it. Easy peasy.</p>
<p>Let's dig in a bit!</p>
<a class="header" href="print.html#we-write-our-kernel-code" id="we-write-our-kernel-code"><h2>We write our kernel code</h2></a>
<p>This is the most straightforward step. Write the code! There is some subtlety
here, but we talked about it earlier in the chapter: we have to cross-compile
to our new platform. We remove the standard library. We configure both the
panic handler and the behavior for when a panic happens.</p>
<p>The rest of this book is largely about what to do during this step of
development, so we won't belabor it here. You type some code, hit save. Done.</p>
<a class="header" href="print.html#building-our-code-with-bootimage-build" id="building-our-code-with-bootimage-build"><h2>Building our code with <code>bootimage build</code></h2></a>
<p>Normally, we build Rust code with <code>cargo build</code>, but for an OS, we use
<code>bootimage</code> instead. This is a tool written by Phil Opperman (who we mentioned
in the preface), and it wraps up another tool, also written by Phil,
<code>cargo-xbuild</code>. That tool wraps Cargo. So, in the end, running <code>bootimage build</code> is not too far away from running <code>cargo build</code> conceptually; it's mostly
that Cargo isn't extensible in the way we need at the moment, so we have
to wrap it.</p>
<a class="header" href="print.html#invoking-cargo-xbuild-to-cross-compile-libcore" id="invoking-cargo-xbuild-to-cross-compile-libcore"><h3>Invoking <code>cargo-xbuild</code> to cross-compile <code>libcore</code></h3></a>
<p><code>cargo-xbuild</code>'s job is to cross compile Rust's <code>core</code> library. You see, Rust
has an interesting relationship between the language and libraries: some
important parts of the language are implemented as a library, not as a
built-in thing. These foundations, and some other goodies, are included in
the <code>core</code> library. So, before we can build our code, we need to build a copy
of <code>core</code> for our OS. <code>cargo-xbuild</code> makes this easy: it knows how to ask
<code>rustup</code> for a copy of <code>core</code>'s source code, and then builds it with our
custom target JSON.</p>
<a class="header" href="print.html#invoking-cargo-to-take-our-configuration-and-set-up-a-build" id="invoking-cargo-to-take-our-configuration-and-set-up-a-build"><h3>Invoking <code>cargo</code> to take our configuration and set up a build</h3></a>
<p>Now that <code>core</code> is built, we can build our code! Cargo is <em>the</em> tool
in Rust for this task, so <code>cargo-xbuild</code> calls on it to do so. It
passes along our custom target JSON to make sure that we're outputting
a binary for the correct target.</p>
<a class="header" href="print.html#invoking-rustc-to-build-the-code" id="invoking-rustc-to-build-the-code"><h3>Invoking <code>rustc</code> to build the code</h3></a>
<p>Cargo doesn't actually build our code: it invokes <code>rustc</code>, the Rust compiler,
to actually do the building. Right now our OS is very simple, but as it
grows, and as we split our code into packages, and use external packages,
it's much nicer to let Cargo handle calling <code>rustc</code> rather than doing it by
hand.</p>
<a class="header" href="print.html#creating-a-bin-file" id="creating-a-bin-file"><h3>Creating a <code>.bin</code> file</h3></a>
<p>Now that we have our OS compiled, we need to prepare it for running. To do
so, <code>bootimage</code> creates a special file, called a <code>.bin</code> file. The <code>.bin</code>
stands for &quot;binary&quot;, and it has no real format. It's just a bunch of binary
code. There's no structure, headings, layout, nothing. Just a big old bag of
bits.</p>
<p>However, that doesn't mean that what's in there is random. You see, when you
start up your computer, something called the BIOS runs first. The BIOS is
all-but hard-coded into your motherboard, and it runs some diagnostic checks
to make sure that everything is in order. It then runs the 'bootloader'.</p>
<p>This is either the most interesting or most boring part of this whole
enterprise. Almost all of this is piles and piles of backwards compatibility
hacks. Since early computers were very small, the bootloader only gets to
have <em>256 bytes</em> of stuff inside it. The eventual goal is to run your OS,
but there's a few other possibilities. For example, maybe you have more
than one OS on your computer, so the bootloader invokes a program that
lets you choose between them. Additionally, even on today's high-powered
CPUs, when the bootloader is invoked, they're in a backwards-compatible mode
that makes them think they're a processor from the 70s. That's right,
we basically didn't ever change the foundations here, simply piled new
things on top. &quot;Oh, you think you're an 8-bit computer? Let's set up
16-bit mode. Oh, now you think you're a 16-bit computer? Let's set up
32-bit mode. Oh, now you think you're a 32-bit computer? Let's set up
64-bit mode.&quot; And <em>then</em> we can finally start our OS.</p>
<p>You may be wondering, &quot;How does the bootloader do all this in only 256 bytes?
This quesiton itself is like 90 bytes!&quot; The answer? Compatibility hacks.
Virutally all bootloaders today are multiple stages: the first tiny bootloader
sets up a secondary bootloader, and that one then can be larger and do more
work.</p>
<p><code>bootimage</code> has a custom-written bootloader that puts your CPU into
64-bit mode, then calls the <code>_start</code> function of our OS. It assembles
the bootloader's code and our OSs' code into that one <code>.bin</code> file.</p>
<a class="header" href="print.html#running-our-code-with-bootimage-run" id="running-our-code-with-bootimage-run"><h2>Running our code with <code>bootimage run</code></h2></a>
<p><code>bootimage run</code> takes our <code>.bin</code> file and passes it to Qemu, the emulator
we discussed earlier in the chapter. Qemu uses the <code>.bin</code> file as the
hard drive, and so when it starts up, its BIOS calls the bootloader
which calls our kernel. It also emulates the screen, so when we start
printing stuff to the screen, we'll see it pop up!</p>
<a class="header" href="print.html#summary" id="summary"><h2>Summary</h2></a>
<p>There's more to explore here, but for now, we're not going to worry about
this stuff. It's very platform-specific, and mostly papering over legacy.
Instead, let's move forward and make our kernel actually <em>do</em> stuff, not
worry about how to put a processor into a specific mode.</p>
<p>In the next chapter, we'll print some characters on the screen!</p>
<a class="header" href="print.html#interlude-fractal-learning" id="interlude-fractal-learning"><h1>Interlude: fractal learning</h1></a>
<p>At this point, we're about to start actually learning about how an OS works,
and start writing real code. Before we do, I'd like to explain <em>how</em> we're
going to learn this stuff. I think this framing is important. I know you're
probably excited to get going, but please bear with me for a moment!</p>
<p>It's impossible to learn everything at once. If you keep digging, you'll find
more questions, and digging into those questions leads to more questions...
at some point, you have to say &quot;okay, I know enough about this for now, it's
time to move on.&quot; You can always come back to a concept later. And sometimes,
you have to go back and forth between different levels of abstraction
numerous times to truly <em>get it</em>. This spirals out, like a fractal, with
an infinite level of zooming in and out.</p>
<p>I think this is something most programmers <em>know</em>, but it can be hard to
remember when working on a hobby operating system. I sometimes think to
myself, &quot;Isn't the whole point that I'm trying to learn all the things, all
the way down? Is skimming this concept for now okay? Am I cheating?&quot;</p>
<p>The answer, of course, is 'no'. There is no cheating. We're doing this to
learn. We'll learn some things at a certain level of abstraction, and
then come back to them later and learn more. That's just the way this works.
And it <em>also</em> means that sometimes, the chapters you're about to read will
say &quot;This is the way this is. It just is. You memorize it and move on.&quot; We're
about to talk about printing characters to the screen, in various colors.
Yellow is represented by a certain number. Why specifically that number?
Well, there is a good reason, but it's 100% irrelevant to writing a yellow
character on the screen. So we say &quot;This color means yellow&quot; and just get
on with life. I've written this VGA code probably ten different times in
at least three different languages in the past ten years, and I didn't know
why that number meant yellow until last night. In the previous sections, we
managed to build a whole &quot;hello world&quot; kernel without understanding fully
what was going on. We then circled back and dug in a bit.</p>
<p>It's okay to not &quot;fully&quot; understand something before moving on, whatever
that means. You'll get back to it. Sometimes, learning something else is
more important than diving into every last detail. And, since you now
have the words to understand what it is you need to learn, coming back
to the topic later is even easier. You have the terms to search for.</p>
<a class="header" href="print.html#printing-to-the-screen-a-text-mode-vga-driver" id="printing-to-the-screen-a-text-mode-vga-driver"><h1>Printing to the screen: a text mode VGA driver</h1></a>
<p>Now that we can build and run our new kernel, it's time to make it actually
do someting! We'll get started by printing stuff to the screen. PC-compatible
computers implement a graphics API called &quot;VGA&quot;, or &quot;video graphics array.&quot;
You'll come to learn quite soon why that's the name!</p>
<p>First, we'll write out the simplest &quot;hello world&quot; possible. Then, we'll dig
a bit deeper into exactly what we did. Finally, we'll refactor our code into
an actual, nice-to-use library.</p>
<a class="header" href="print.html#a-vga-hello-world" id="a-vga-hello-world"><h1>A VGA &quot;hello world&quot;</h1></a>
<p>In the previous chapter, we set up a &quot;hello world&quot; kernel, but we didn't even
print &quot;hello world&quot; to the screen! Let's fix that. Open up your <code>src/main.rs</code>
and modify your <code>_start()</code> function to look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub fn _start() -&gt; ! {
    let slice = unsafe { core::slice::from_raw_parts_mut(0xb8000 as *mut u8, 4000) };

    slice[0] = b'h';
    slice[1] = 0x02;
    slice[2] = b'e';
    slice[3] = 0x02;
    slice[4] = b'l';
    slice[5] = 0x02;
    slice[6] = b'l';
    slice[7] = 0x02;
    slice[8] = b'o';
    slice[9] = 0x02;
    slice[10] = b' ';
    slice[11] = 0x02;
    slice[12] = b'w';
    slice[13] = 0x02;
    slice[14] = b'o';
    slice[15] = 0x02;
    slice[16] = b'r';
    slice[17] = 0x02;
    slice[18] = b'l';
    slice[19] = 0x02;
    slice[20] = b'd';
    slice[21] = 0x02;

    loop {}
}
#}</code></pre></pre>
<p>If you compile and build with <code>bootimage run</code>, you should see something like
this appear!</p>
<p><img alt="program on hardware" class="center" src="assets/hello-ascii.png" /></p>
<p>Congrats! You've gotten it to print to the screen. If you look at the code above, you
<em>may</em> be getting an idea of why VGA is called &quot;video graphics array&quot;... in the next
section, we'll explain what the code above is actually doing.</p>
<a class="header" href="print.html#understanding-text-mode" id="understanding-text-mode"><h1>Understanding text mode</h1></a>
<p>Coming soon!</p>
<a class="header" href="print.html#a-nicer-implementation" id="a-nicer-implementation"><h1>A nicer implementation</h1></a>
<p>Coming soon!</p>
<a class="header" href="print.html#appendix-a-target-specifications" id="appendix-a-target-specifications"><h1>Appendix A: target specifications</h1></a>
<p>In Chapter 2, we created <code>intermezzos.json</code>, a &quot;target specification.&quot;
Here's the reasons for setting each thing:</p>
<pre><code class="language-json">  &quot;llvm-target&quot;: &quot;x86_64-unknown-none&quot;,
</code></pre>
<p>This is called a &quot;target triple&quot;, and is fed to <a href="http://llvm.org/">LLVM</a>, the
project that <code>rustc</code> uses to generate the final binary code. It's called a &quot;triple&quot;
becuase it has three parts: the CPU, the vendor, and the OS. So for this target,
we choose the x86_64 CPU, an 'unknown' vendor since we're not a big company or
something, and 'none' for the OS, since our OS does not rely on an OS.</p>
<pre><code class="language-json">  &quot;data-layout&quot;: &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;,
</code></pre>
<p>This is another LLVM thing, you can find the documentation
<a href="http://llvm.org/docs/LangRef.html#data-layout">here</a>. Honestly, it's not
very interesting; feel free to read those docs if you want to learn more.</p>
<pre><code class="language-json">  &quot;arch&quot;: &quot;x86_64&quot;,
</code></pre>
<p>This also sets our CPU architecture; as we said in the target above, it's <code>x86_64</code>.</p>
<pre><code class="language-json">  &quot;target-endian&quot;: &quot;little&quot;,
</code></pre>
<p>&quot;Endian-ness&quot; is a property of how binary numbers are transmitted; there are three
forms: &quot;big endian,&quot; &quot;little endian,&quot; and &quot;network endian&quot;, which is a synonym for
&quot;big endian.&quot; This is because most network protocols choose big endian.</p>
<p>Intel uses little endian for their processors, however, and so we set that here.</p>
<pre><code class="language-json">  &quot;target-pointer-width&quot;: &quot;64&quot;,
</code></pre>
<p>We're building a 64-bit OS, so our pointers are 64 bits wide. If you don't know what
a pointer is, don't worry about it yet.</p>
<pre><code class="language-json">  &quot;target-c-int-width&quot;: &quot;32&quot;,
</code></pre>
<p>We're not using C, so this doesn't matter, but if we were, we'd make integers
32 bits. This is common on the x86_64 platform.</p>
<pre><code class="language-json">  &quot;os&quot;: &quot;none&quot;,
</code></pre>
<p>We don't have an OS! We're building one!</p>
<pre><code class="language-json">  &quot;linker&quot;: &quot;rust-lld&quot;,
  &quot;linker-flavor&quot;: &quot;ld.lld&quot;,
</code></pre>
<p>We'll be using <a href="https://lld.llvm.org/">LLD</a> for linking; this linker is
provided by the LLVM project, and automatically distributed with Rust.</p>
<pre><code class="language-json">  &quot;executables&quot;: true,
</code></pre>
<p>Are executables allowed on this target, or only libraries? That might
sound silly, but iOS, for example, won't let you create executables.</p>
<pre><code class="language-json">  &quot;features&quot;: &quot;-mmx,-sse,+soft-float&quot;,
</code></pre>
<p>These flags control the kind of code that Rust generates. For reasons we
won't get into right now, many kernels don't use floating point numbers or
<a href="https://en.wikipedia.org/wiki/SIMD">SIMD registers</a> in the kernel, so we
want to turn those options off. (MMX is a similar feature to SIMD). &quot;soft
float&quot; means to not use actual floating point hardware instructions, but to
emulate them in software. We won't be using floating point numbers at all,
directly, but just in case, we want to make sure that we're not going to be
using the hardware for it. We'll talk more about this later.</p>
<pre><code class="language-json">  &quot;disable-redzone&quot;: true,
</code></pre>
<p>This is a very tricky one! The x86_64 &quot;calling convention&quot;, that is, the way
that assembly code for functions is called, allows for a thing called the
&quot;red zone.&quot; We <em>do not want</em> this for a kernel. Forgetting this setting runs
into all kinds of really strange looking bugs.</p>
<pre><code class="language-json">  &quot;panic-strategy&quot;: &quot;abort&quot;
</code></pre>
<p>Finally, we don't want to use Rust's panics, so by setting them to abort
instead of unwind, we don't generate code to handle panics.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
